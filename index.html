<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Heart of Bits</title>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
  html, body { height: 100%; margin: 0; background:#080a0f; }
  canvas { display:block; width:100%; height:100%; touch-action:none; }
  .hint {
    position:fixed; left:12px; bottom:12px; font:12px/1.2 system-ui,Segoe UI,Inter,Arial;
    color:#8bd7ff; opacity:0.85; user-select:none; letter-spacing:.2px
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Arraste o dedo ou passe o mouse para puxar. Toque ou clique rápido para strobes. R ou Espaço reinicia.</div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H, DPR, center, baseScale;

  // Nós e arestas
  let nodes = [];                 // {x0,y0,bit,group}
  let edgesHeart = [];            // {i,j}
  let edgesText  = [];            // {i,j}
  const GROUP_HEART = 1;
  const GROUP_TEXT  = 2;

  // Layout do texto em duas linhas
  let textLayout = null;          // {lines:[{text, chars:[{ch,x,y,w}] }], fontPxWorld}

  // Ponteiro unificado
  const pointer = { x:0, y:0, active:false, radius:0, pull:1.15 };
  const clickTimes = [];
  const strobes = [];
  let overlayAlpha = 0;

  const MESSAGE_FULL = "Fernandinha, sua pele está linda!";

  // Stacks de fonte
  const FONT_UI = "Rajdhani, Orbitron, 'Segoe UI', Arial, sans-serif";
  const FONT_MONO = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

  // Parâmetros
  const params = {
    // mais densidade no coração
    targetCountWide: 1900,
    targetCountNarrow: 1400,
    heartRatio: 0.72,

    // ligações
    linkRadiusHeart: 62,
    linksPerHeart: 4,
    linkRadiusText: 34,
    linksPerText: 2,

    preScale: 0.42,
    bitFontPxDesktop: 14,
    bitFontPxMobile: 13,
    lineWidth: 1.1,

    // cores
    colorBits: "rgba(255,255,255,0.95)",
    colorHeartA: "rgba(0,229,255,0.22)",
    colorHeartB: "rgba(122,60,255,0.30)",
    colorTextA:  "rgba(0,229,255,0.12)",
    colorTextB:  "rgba(122,60,255,0.16)",

    // respiração
    breatheAmp: 0.010,
    breatheFreq: 2.2,

    // strobes
    strobeWindowMs: 800,
    strobeOverlayGain: 0.35,
    strobeBase: 5,
    strobeFactor: 8,
    strobeVR: 950,
    strobeFade: 0.86,

    // texto
    textSizeFactor: 0.24,     // menor que antes para reduzir o tamanho
    textLineHeight: 1.14,     // compacto e legível
    textDisplaceStrength: 0.26
  };

  function resize(){
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    W = Math.floor(cssW * DPR);
    H = Math.floor(cssH * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    center = { x: W*0.5, y: H*0.5 };
    baseScale = Math.min(W, H) * params.preScale;

    const bitSize = cssW < 700 ? params.bitFontPxMobile : params.bitFontPxDesktop;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.font = `${Math.round(bitSize*DPR)}px ${FONT_MONO}`;

    pointer.radius = (cssW < 700 ? 120 : 150) * DPR;
    pointer.pull   = cssW < 700 ? 1.30 : 1.18;

    regenerate();
  }

  // Coração emoji em pé
  function heartEmojiInside(nx, ny){
    const x = nx;
    const y = -ny * 1.10; // corrige orientação no canvas
    const f = Math.pow(x*x + y*y - 1, 3) - x*x*y*y*y;
    return f <= 0.02;
  }

  function splitIntoTwoLines(text, measureFn, maxWidth){
    const words = text.split(' ');
    if(words.length < 2) return [text, ""];
    let best = null;
    for(let i=1;i<words.length;i++){
      const line1 = words.slice(0,i).join(' ');
      const line2 = words.slice(i).join(' ');
      const w1 = measureFn(line1);
      const w2 = measureFn(line2);
      if(w1 <= maxWidth && w2 <= maxWidth){
        const diff = Math.abs(w1 - w2);
        if(!best || diff < best.diff) best = {line1, line2, diff};
      }
    }
    if(best) return [best.line1, best.line2];
    const mid = Math.ceil(words.length/2);
    return [words.slice(0,mid).join(' '), words.slice(mid).join(' ')];
  }

  function regenerate(){
    nodes = []; edgesHeart = []; edgesText = []; textLayout = null;

    const cssW = W / DPR;
    const wide = cssW >= 900;

    // Layout responsivo
    let heartC = { x: center.x, y: center.y };
    let heartScale = baseScale * (wide ? 1.08 : 1.02);

    let textBox = { cx:center.x, cy:center.y, w: W*0.8, h: H*0.34 };
    if(wide){
      heartC.x = W*0.33;
      heartC.y = H*0.50;
      textBox.cx = W*0.72;
      textBox.cy = H*0.50;
      textBox.w  = W*0.46;
      textBox.h  = H*0.50;
    }else{
      heartC.x = center.x;
      heartC.y = H*0.38;
      textBox.cx = center.x;
      textBox.cy = H*0.78;
      textBox.w  = W*0.90;
      textBox.h  = H*0.34;
    }

    // Densidade
    const totalTarget = Math.floor(wide ? params.targetCountWide : params.targetCountNarrow);
    const heartTarget = Math.floor(totalTarget * params.heartRatio);
    const textTarget  = totalTarget - heartTarget;

    // Coração mais denso
    addHeartNodes(heartTarget, heartC, heartScale);

    // Texto em duas linhas com fonte tech
    addTextWithMesh(MESSAGE_FULL, textTarget, textBox);

    // Ligações
    buildEdgesForGroup(GROUP_HEART, params.linkRadiusHeart, params.linksPerHeart, edgesHeart);
    buildEdgesForGroup(GROUP_TEXT,  params.linkRadiusText,  params.linksPerText,  edgesText);
  }

  function addHeartNodes(count, anchor, scale){
    const maxTries = count * 60;
    let tries = 0;
    while(nodes.filter(n=>n.group===GROUP_HEART).length < count && tries < maxTries){
      tries++;
      const nx = Math.random()*2.4 - 1.2;
      const ny = Math.random()*2.4 - 1.2;
      if(!heartEmojiInside(nx, ny)) continue;
      const px = anchor.x + nx*scale;
      const py = anchor.y + ny*scale*0.97;
      const bit = Math.random() < 0.5 ? "0" : "1";
      nodes.push({ x0:px, y0:py, bit, group:GROUP_HEART });
    }
  }

  function addTextWithMesh(text, count, box){
    // offscreen para medir e amostrar
    const off = document.createElement('canvas');
    const scaleDown = (W/DPR < 700 ? 0.9 : 1.0);
    off.width  = Math.max(160, Math.floor(box.w * scaleDown));
    off.height = Math.max(120, Math.floor(box.h * scaleDown));
    const octx = off.getContext('2d');

    // escolher tamanho e quebrar em 2 linhas
    let size = Math.floor(off.height * params.textSizeFactor);
    const lineH = params.textLineHeight;
    octx.textBaseline = 'middle';
    octx.textAlign = 'center';

    function measureLine(s){ octx.font = `700 ${size}px ${FONT_UI}`; return octx.measureText(s).width; }

    let lines;
    do{
      octx.font = `700 ${size}px ${FONT_UI}`;
      lines = splitIntoTwoLines(text, s => octx.measureText(s).width, off.width*0.92);
      const blockHeight = size*lineH*2;
      if(blockHeight <= off.height*0.92 && measureLine(lines[0]) <= off.width*0.92 && measureLine(lines[1]) <= off.width*0.92) break;
      size -= 2;
      if(size < 14) break;
    }while(true);

    // render no offscreen
    octx.clearRect(0,0,off.width,off.height);
    octx.fillStyle = '#fff';
    const cy = off.height*0.5;
    const y1 = cy - size*lineH*0.5;
    const y2 = cy + size*lineH*0.5;
    octx.fillText(lines[0], off.width*0.5, y1);
    octx.fillText(lines[1], off.width*0.5, y2);

    // layout para canvas principal
    const scaleInv = 1/scaleDown;
    const fontPxWorld = size * scaleInv;
    const worldY1 = box.cy + (y1 - off.height*0.5) * scaleInv;
    const worldY2 = box.cy + (y2 - off.height*0.5) * scaleInv;

    // posições por caractere
    const measureCtx = document.createElement('canvas').getContext('2d');
    measureCtx.font = `700 ${fontPxWorld}px ${FONT_UI}`;
    function charsForLine(str, yWorld){
      const w = measureCtx.measureText(str).width;
      const startX = box.cx - w*0.5;
      const arr = [];
      let acc = 0;
      for(const ch of str){
        const cw = measureCtx.measureText(ch).width;
        const cx = startX + acc + cw*0.5;
        arr.push({ ch, x: cx, y: yWorld, w: cw });
        acc += cw;
      }
      return arr;
    }
    textLayout = {
      fontPxWorld,
      lines: [
        { text: lines[0], chars: charsForLine(lines[0], worldY1) },
        { text: lines[1], chars: charsForLine(lines[1], worldY2) }
      ]
    };

    // malha de pontos invisíveis para as linhas do texto
    const img = octx.getImageData(0,0,off.width,off.height).data;
    const pixels = off.width * off.height;
    let step = Math.max(3, Math.floor(Math.sqrt(pixels / Math.max(1, count))));
    let placed = 0;
    const threshold = 32;

    function tryGrid(passStep){
      for(let y=passStep*0.5; y<off.height; y+=passStep){
        for(let x=passStep*0.5; x<off.width; x+=passStep){
          const xi = Math.floor(x), yi = Math.floor(y);
          const a = img[(yi*off.width + xi)*4 + 3];
          if(a > threshold){
            const jitter = passStep*0.35;
            const wx = box.cx + (x - off.width*0.5)*scaleInv + (Math.random()*2-1)*jitter;
            const wy = box.cy + (y - off.height*0.5)*scaleInv + (Math.random()*2-1)*jitter;
            nodes.push({ x0:wx, y0:wy, bit:null, group:GROUP_TEXT });
            placed++;
            if(placed >= count) return true;
          }
        }
      }
      return false;
    }
    if(!tryGrid(step)){
      step = Math.max(2, Math.floor(step*0.8));
      if(!tryGrid(step)){
        step = Math.max(2, Math.floor(step*0.8));
        tryGrid(step);
      }
    }
  }

  function buildEdgesForGroup(group, linkRadiusCss, maxLinks, outEdges){
    const idx = [];
    for(let i=0;i<nodes.length;i++) if(nodes[i].group===group) idx.push(i);
    const r2 = (linkRadiusCss*DPR)*(linkRadiusCss*DPR);
    for(let a=0;a<idx.length;a++){
      const i = idx[a], ai = nodes[i];
      const nbs = [];
      for(let b=0;b<idx.length;b++){
        if(a===b) continue;
        const j = idx[b], bj = nodes[j];
        const dx = bj.x0 - ai.x0;
        const dy = bj.y0 - ai.y0;
        const d2 = dx*dx + dy*dy;
        if(d2 <= r2) nbs.push({j, d2});
      }
      nbs.sort((p,q)=>p.d2 - q.d2);
      const take = Math.min(maxLinks, nbs.length);
      for(let k=0;k<take;k++){
        const j = nbs[k].j;
        if(i < j) outEdges.push({i,j});
      }
    }
  }

  function clamp(v,a,b){ return v<a?a: v>b?b: v; }
  function smoothstep(edge0, edge1, x){
    const t = clamp((x - edge0)/(edge1 - edge0), 0, 1);
    return t*t*(3 - 2*t);
  }

  function pointerDisplacement(x, y, strength=params.textDisplaceStrength){
    if(!pointer.active) return {dx:0, dy:0};
    const dx = pointer.x - x, dy = pointer.y - y;
    const d = Math.hypot(dx, dy);
    if(d >= pointer.radius) return {dx:0, dy:0};
    const s = smoothstep(0, 1, 1 - d/pointer.radius);
    const k = pointer.pull * strength;
    return { dx: dx*s*k, dy: dy*s*k };
  }

  function animate(now){
    const dt = Math.min(0.033, (now - (animate._last||now))/1000);
    animate._last = now;

    const t = now/1000;
    const breathe = 1 + params.breatheAmp * Math.sin(t*params.breatheFreq);

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    // offsets acumulados pelos puxões
    const offX = new Float32Array(nodes.length);
    const offY = new Float32Array(nodes.length);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = params.lineWidth * DPR;

    function drawEdges(list, color, opacity){
      ctx.strokeStyle = color;
      ctx.beginPath();
      for(let e=0; e<list.length; e++){
        const i = list[e].i, j = list[e].j;
        const ai = nodes[i], bj = nodes[j];

        let ax = center.x + (ai.x0 - center.x)*breathe;
        let ay = center.y + (ai.y0 - center.y)*breathe;
        let bx = center.x + (bj.x0 - center.x)*breathe;
        let by = center.y + (bj.y0 - center.y)*breathe;

        // curvatura por ponteiro
        let useCurve = false, cx=0, cy=0, s=0;
        if(pointer.active){
          const mx = pointer.x, my = pointer.y;
          const dx = bx - ax, dy = by - ay;
          const len2 = dx*dx + dy*dy || 1;
          const tproj = ((mx - ax)*dx + (my - ay)*dy) / len2;
          const tc = clamp(tproj, 0, 1);
          const qx = ax + dx*tc;
          const qy = ay + dy*tc;
          const d = Math.hypot(mx - qx, my - qy);
          if(d < pointer.radius){
            const midx = (ax + bx)*0.5;
            const midy = (ay + by)*0.5;
            const pull = 1 - (d / pointer.radius);
            s = smoothstep(0, 1, pull);
            cx = midx + (mx - midx) * s * pointer.pull;
            cy = midy + (my - midy) * s * pointer.pull;
            useCurve = true;

            // endpoints acompanham um pouco
            const dax = (cx - ax) * 0.35 * s;
            const day = (cy - ay) * 0.35 * s;
            const dbx = (cx - bx) * 0.35 * s;
            const dby = (cy - by) * 0.35 * s;
            offX[i] += dax; offY[i] += day;
            offX[j] += dbx; offY[j] += dby;

            ax += dax; ay += day; bx += dbx; by += dby;
          }
        }

        ctx.moveTo(ax, ay);
        if(useCurve) ctx.quadraticCurveTo(cx, cy, bx, by);
        else ctx.lineTo(bx, by);
      }
      ctx.globalAlpha = opacity;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Camadas de linhas
    drawEdges(edgesHeart, params.colorHeartA, 1.0);
    drawEdges(edgesHeart, params.colorHeartB, 1.0);
    drawEdges(edgesText,  params.colorTextA,  1.0);
    drawEdges(edgesText,  params.colorTextB,  1.0);

    // Dígitos do coração
    const bitSizeCss = (W/DPR < 700 ? params.bitFontPxMobile : params.bitFontPxDesktop);
    ctx.font = `${Math.round(bitSizeCss*DPR)}px ${FONT_MONO}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for(let i=0;i<nodes.length;i++){
      const nd = nodes[i];
      if(nd.group !== GROUP_HEART) continue;
      const x = center.x + (nd.x0 - center.x)*breathe + offX[i];
      const y = center.y + (nd.y0 - center.y)*breathe + offY[i];

      // halo
      ctx.fillStyle = "rgba(0,229,255,0.06)";
      ctx.beginPath(); ctx.arc(x, y, 7*DPR, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = params.colorBits;
      ctx.fillText(nd.bit, x, y);
    }

    // Texto nítido em duas linhas com fonte tech
    if(textLayout){
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `700 ${Math.round(textLayout.fontPxWorld*DPR)}px ${FONT_UI}`;

      for(const line of textLayout.lines){
        for(const ch of line.chars){
          const disp = pointerDisplacement(ch.x, ch.y, params.textDisplaceStrength);
          const tx = ch.x + disp.dx;
          const ty = ch.y + disp.dy;

          // contorno discreto para legibilidade
          ctx.lineWidth = 1 * DPR;
          ctx.strokeStyle = "rgba(10,11,15,0.70)";
          ctx.strokeText(ch.ch, tx, ty);

          ctx.fillStyle = "#ffffff";
          ctx.fillText(ch.ch, tx, ty);
        }
      }
    }

    // Strobes
    if(strobes.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(let k=strobes.length-1; k>=0; k--){
        const p = strobes[k];
        p.r += p.vr * dt;
        p.a *= params.strobeFade;
        if(p.a < 0.02){ strobes.splice(k,1); continue; }
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        grad.addColorStop(0, `rgba(255,255,255,${0.12*p.a})`);
        grad.addColorStop(0.7, `rgba(0,229,255,${0.18*p.a})`);
        grad.addColorStop(1, `rgba(122,60,255,${0.10*p.a})`);
        ctx.fillStyle = grad;
        ctx.fill();
      }
      ctx.restore();
    }

    if(overlayAlpha > 0.003){
      overlayAlpha *= 0.90;
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255,${overlayAlpha*0.45})`;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    requestAnimationFrame(animate);
  }

  // Ponteiro
  function setPointerFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    pointer.x = (ev.clientX - rect.left) * DPR;
    pointer.y = (ev.clientY - rect.top) * DPR;
    pointer.active = true;
  }
  canvas.addEventListener('pointermove', e=>{ setPointerFromEvent(e); }, {passive:true});
  canvas.addEventListener('pointerdown', e=>{
    setPointerFromEvent(e);
    const now = performance.now();
    clickTimes.push(now);
    while(clickTimes.length && now - clickTimes[0] > params.strobeWindowMs) clickTimes.shift();
    const rate = clickTimes.length;
    const amp = Math.min(1, rate/6);
    const n = params.strobeBase + Math.floor(params.strobeFactor * amp);
    for(let k=0;k<n;k++){
      const ang = Math.random()*Math.PI*2;
      const jitter = (Math.random()*10 + 8) * DPR;
      const x = pointer.x + Math.cos(ang)*jitter;
      const y = pointer.y + Math.sin(ang)*jitter;
      strobes.push({ x, y, r: 6*DPR, vr: params.strobeVR*DPR*(0.7+Math.random()*0.6), a: 0.9 });
    }
    overlayAlpha = Math.min(1, overlayAlpha + params.strobeOverlayGain * amp);
  }, {passive:true});
  canvas.addEventListener('pointerup',   ()=>{ pointer.active = false; }, {passive:true});
  canvas.addEventListener('pointerleave',()=>{ pointer.active = false; }, {passive:true});
  window.addEventListener('keydown', e=>{ if(e.code === 'Space' || e.key === 'r' || e.key === 'R'){ regenerate(); }});
  window.addEventListener('resize', resize);

  // Init
  resize();
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>

