<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Fernanda Gostosa</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700&display=swap" rel="stylesheet">
<style>
  html, body { height: 100%; margin: 0; background:#080a0f; }
  canvas { display:block; width:100%; height:100%; touch-action:none; }
  .hint {
    position:fixed; left:12px; bottom:12px; font:12px/1.2 system-ui,Segoe UI,Inter,Arial;
    color:#8bd7ff; opacity:0.85; user-select:none; letter-spacing:.2px
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Arraste o dedo ou passe o mouse para puxar. Toque/click rápido para strobes. R ou Espaço reinicia.</div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H, DPR, center, baseScale;

  // Nós e arestas
  let nodes = [];                 // {x0,y0,bit,group}
  let edgesHeart = [];            // {i,j}
  const GROUP_HEART = 1;

  // BLOCO DE TEXTO ESTÁTICO (sem interação)
  let textBlock = null;           // {lines:[l1,l2], fontPx, y1,y2, x}

  // Ponteiro (continua para o coração)
  const pointer = { x:0, y:0, active:false, radius:0, pull:1.18 };
  const clickTimes = [];
  const strobes = [];
  let overlayAlpha = 0;

  const MESSAGE_FULL = "Fernandinha, sua pele está linda!";

  // Fontes
  const FONT_UI = "Inter, system-ui, 'Segoe UI', Arial, sans-serif";
  const FONT_MONO = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

  // Parâmetros
  const params = {
    targetCountWide: 1900,
    targetCountNarrow: 1400,
    heartRatio: 0.72,

    // ligações (coração)
    linkRadiusHeart: 62,
    linksPerHeart: 4,

    preScale: 0.42,
    bitFontPxDesktop: 14,
    bitFontPxMobile: 13,
    lineWidth: 1.1,

    // cores
    colorBits: "rgba(255,255,255,0.95)",
    colorHeartA: "rgba(0,229,255,0.22)",
    colorHeartB: "rgba(122,60,255,0.30)",

    // respiração
    breatheAmp: 0.010,
    breatheFreq: 2.2,

    // strobes
    strobeWindowMs: 800,
    strobeOverlayGain: 0.35,
    strobeBase: 5,
    strobeFactor: 8,
    strobeVR: 950,
    strobeFade: 0.86,

    // TEXTO ESTÁTICO
    textSizeFactor: 0.16,          // desktop
    textSizeFactorMobile: 0.085,    // mobile menor
    textMaxPxDesktop: 34,           // teto
    textMaxPxMobile: 22,            // teto mobile
    textLineHeight: 1.30            // mais espaço
  };

  function resize(){
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = window.innerWidth;
    const cssH = window.innerHeight;
    W = Math.floor(cssW * DPR);
    H = Math.floor(cssH * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    center = { x: W*0.5, y: H*0.5 };
    baseScale = Math.min(W, H) * params.preScale;

    const bitSize = cssW < 700 ? params.bitFontPxMobile : params.bitFontPxDesktop;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.font = `${Math.round(bitSize*DPR)}px ${FONT_MONO}`;

    pointer.radius = (cssW < 700 ? 120 : 150) * DPR;
    pointer.pull   = cssW < 700 ? 1.30 : 1.18;

    regenerate();
  }

  // Coração emoji em pé
  function heartEmojiInside(nx, ny){
    const x = nx;
    const y = -ny * 1.10; // corrige orientação no canvas
    const f = Math.pow(x*x + y*y - 1, 3) - x*x*y*y*y;
    return f <= 0.02;
  }

  function splitIntoTwoLines(text, measureFn, maxWidth){
    const words = text.split(' ');
    if(words.length < 2) return [text, ""];
    let best = null;
    for(let i=1;i<words.length;i++){
      const line1 = words.slice(0,i).join(' ');
      const line2 = words.slice(i).join(' ');
      const w1 = measureFn(line1);
      const w2 = measureFn(line2);
      if(w1 <= maxWidth && w2 <= maxWidth){
        const diff = Math.abs(w1 - w2);
        if(!best || diff < best.diff) best = {line1, line2, diff};
      }
    }
    if(best) return [best.line1, best.line2];
    const mid = Math.ceil(words.length/2);
    return [words.slice(0,mid).join(' '), words.slice(mid).join(' ')];
  }

  function regenerate(){
    nodes = []; edgesHeart = []; textBlock = null;

    const cssW = W / DPR;
    const wide = cssW >= 900;

    // Layout do coração (inalterado)
    let heartC = { x: center.x, y: center.y };
    let heartScale = baseScale * (wide ? 1.08 : 1.02);

    // Caixa do texto
    let textBox = { cx:center.x, cy:center.y, w: W*0.8, h: H*0.34 };
    if(wide){
      heartC.x = W*0.33;
      heartC.y = H*0.50;
      textBox.cx = W*0.72;
      textBox.cy = H*0.50;
      textBox.w  = W*0.46;
      textBox.h  = H*0.50;
    }else{
      heartC.x = center.x;
      heartC.y = H*0.38;
      textBox.cx = center.x;
      textBox.cy = H*0.78;
      textBox.w  = W*0.90;
      textBox.h  = H*0.34;
    }

    // Densidade
    const totalTarget = Math.floor(wide ? params.targetCountWide : params.targetCountNarrow);
    const heartTarget = Math.floor(totalTarget * params.heartRatio);

    // Coração (inalterado)
    addHeartNodes(heartTarget, heartC, heartScale);
    buildEdgesForHeart();

    // Texto estático: calcula tamanho e posições; NÃO cria nós/arestas
    buildStaticText(MESSAGE_FULL, textBox);
  }

  function addHeartNodes(count, anchor, scale){
    const maxTries = count * 60;
    let tries = 0;
    while(nodes.filter(n=>n.group===GROUP_HEART).length < count && tries < maxTries){
      tries++;
      const nx = Math.random()*2.4 - 1.2;
      const ny = Math.random()*2.4 - 1.2;
      if(!heartEmojiInside(nx, ny)) continue;
      const px = anchor.x + nx*scale;
      const py = anchor.y + ny*scale*0.97;
      const bit = Math.random() < 0.5 ? "0" : "1";
      nodes.push({ x0:px, y0:py, bit, group:GROUP_HEART });
    }
  }

  function buildEdgesForHeart(){
    const idx = [];
    for(let i=0;i<nodes.length;i++) if(nodes[i].group===GROUP_HEART) idx.push(i);
    const r2 = (params.linkRadiusHeart*DPR)*(params.linkRadiusHeart*DPR);
    for(let a=0;a<idx.length;a++){
      const i = idx[a], ai = nodes[i];
      const nbs = [];
      for(let b=0;b<idx.length;b++){
        if(a===b) continue;
        const j = idx[b], bj = nodes[j];
        const dx = bj.x0 - ai.x0;
        const dy = bj.y0 - ai.y0;
        const d2 = dx*dx + dy*dy;
        if(d2 <= r2) nbs.push({j, d2});
      }
      nbs.sort((p,q)=>p.d2 - q.d2);
      const take = Math.min(params.linksPerHeart, nbs.length);
      for(let k=0;k<take;k++){
        const j = nbs[k].j;
        if(i < j) edgesHeart.push({i,j});
      }
    }
  }

  // Texto puramente estático
  function buildStaticText(text, box){
    const isMobile = (W/DPR < 700);
    const scaleDown = isMobile ? 0.9 : 1.0;

    // canvas offscreen só para medir
    const off = document.createElement('canvas');
    off.width  = Math.max(160, Math.floor(box.w * scaleDown));
    off.height = Math.max(120, Math.floor(box.h * scaleDown));
    const octx = off.getContext('2d');

    let size = Math.floor(off.height * (isMobile ? params.textSizeFactorMobile : params.textSizeFactor));
    size = Math.min(size, isMobile ? params.textMaxPxMobile : params.textMaxPxDesktop);

    const lineH = params.textLineHeight;
    const targetW = off.width * 0.85;
    const targetH = off.height * 0.70;

    function fit(linesize){
      octx.font = `600 ${linesize}px ${FONT_UI}`;
      const lines = splitIntoTwoLines(text, s => octx.measureText(s).width, targetW);
      const w1 = octx.measureText(lines[0]).width;
      const w2 = octx.measureText(lines[1]).width;
      const blockH = linesize*lineH*2;
      return {lines, ok: (w1<=targetW && w2<=targetW && blockH<=targetH)};
    }

    let info = fit(size);
    while(!info.ok && size>10){
      size -= 2;
      info = fit(size);
    }

    // coordenadas finais no canvas principal
    const fontPx = size * (1/scaleDown);
    const cy = box.cy;
    const y1 = cy - fontPx*lineH*0.5;
    const y2 = cy + fontPx*lineH*0.5;

    textBlock = {
      lines: info.lines,
      fontPx: fontPx,
      x: box.cx,
      y1, y2
    };
  }

  function clamp(v,a,b){ return v<a?a: v>b?b: v; }
  function smoothstep(edge0, edge1, x){
    const t = clamp((x - edge0)/(edge1 - edge0), 0, 1);
    return t*t*(3 - 2*t);
  }

  function animate(now){
    const dt = Math.min(0.033, (now - (animate._last||now))/1000);
    animate._last = now;

    const t = now/1000;
    const breathe = 1 + params.breatheAmp * Math.sin(t*params.breatheFreq);

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    const offX = new Float32Array(nodes.length);
    const offY = new Float32Array(nodes.length);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = params.lineWidth * DPR;

    // Linhas do coração (inalterado, interativo)
    function drawEdges(list, color, opacity){
      ctx.strokeStyle = color;
      ctx.beginPath();
      for(let e=0; e<list.length; e++){
        const i = list[e].i, j = list[e].j;
        const ai = nodes[i], bj = nodes[j];

        let ax = center.x + (ai.x0 - center.x)*breathe;
        let ay = center.y + (ai.y0 - center.y)*breathe;
        let bx = center.x + (bj.x0 - center.x)*breathe;
        let by = center.y + (bj.y0 - center.y)*breathe;

        // curvatura por ponteiro (mantido para o coração)
        let useCurve = false, cx=0, cy=0, s=0;
        if(pointer.active){
          const mx = pointer.x, my = pointer.y;
          const dx = bx - ax, dy = by - ay;
          const len2 = dx*dx + dy*dy || 1;
          const tproj = ((mx - ax)*dx + (my - ay)*dy) / len2;
          const tc = clamp(tproj, 0, 1);
          const qx = ax + dx*tc;
          const qy = ay + dy*tc;
          const d = Math.hypot(mx - qx, my - qy);
          if(d < pointer.radius){
            const midx = (ax + bx)*0.5;
            const midy = (ay + by)*0.5;
            const pull = 1 - (d / pointer.radius);
            s = smoothstep(0, 1, pull);
            cx = midx + (mx - midx) * s * pointer.pull;
            cy = midy + (my - midy) * s * pointer.pull;
            useCurve = true;

            const dax = (cx - ax) * 0.35 * s;
            const day = (cy - ay) * 0.35 * s;
            const dbx = (cx - bx) * 0.35 * s;
            const dby = (cy - by) * 0.35 * s;
            offX[i] += dax; offY[i] += day;
            offX[j] += dbx; offY[j] += dby;

            ax += dax; ay += day; bx += dbx; by += dby;
          }
        }

        ctx.moveTo(ax, ay);
        if(useCurve) ctx.quadraticCurveTo(cx, cy, bx, by);
        else ctx.lineTo(bx, by);
      }
      ctx.globalAlpha = opacity;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    drawEdges(edgesHeart, params.colorHeartA, 1.0);
    drawEdges(edgesHeart, params.colorHeartB, 1.0);

    // Dígitos do coração (inalterado)
    const bitSizeCss = (W/DPR < 700 ? params.bitFontPxMobile : params.bitFontPxDesktop);
    ctx.font = `${Math.round(bitSizeCss*DPR)}px ${FONT_MONO}`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for(let i=0;i<nodes.length;i++){
      const nd = nodes[i];
      if(nd.group !== GROUP_HEART) continue;
      const x = center.x + (nd.x0 - center.x)*breathe + offX[i];
      const y = center.y + (nd.y0 - center.y)*breathe + offY[i];

      ctx.fillStyle = "rgba(0,229,255,0.06)";
      ctx.beginPath(); ctx.arc(x, y, 7*DPR, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = params.colorBits;
      ctx.fillText(nd.bit, x, y);
    }

    // FRASE ESTÁTICA (sem interação)
    if(textBlock){
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `600 ${Math.round(textBlock.fontPx*DPR)}px ${FONT_UI}`;

      // leve contorno para contraste
      ctx.lineWidth = 1 * DPR;
      ctx.strokeStyle = "rgba(10,11,15,0.70)";
      ctx.strokeText(textBlock.lines[0], textBlock.x, textBlock.y1);
      ctx.strokeText(textBlock.lines[1], textBlock.x, textBlock.y2);

      ctx.fillStyle = "#ffffff";
      ctx.fillText(textBlock.lines[0], textBlock.x, textBlock.y1);
      ctx.fillText(textBlock.lines[1], textBlock.x, textBlock.y2);
    }

    // Strobes (inalterado)
    if(strobes.length){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for(let k=strobes.length-1; k>=0; k--){
        const p = strobes[k];
        p.r += p.vr * dt;
        p.a *= params.strobeFade;
        if(p.a < 0.02){ strobes.splice(k,1); continue; }
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
        grad.addColorStop(0, `rgba(255,255,255,${0.12*p.a})`);
        grad.addColorStop(0.7, `rgba(0,229,255,${0.18*p.a})`);
        grad.addColorStop(1, `rgba(122,60,255,${0.10*p.a})`);
        ctx.fillStyle = grad;
        ctx.fill();
      }
      ctx.restore();
    }

    if(overlayAlpha > 0.003){
      overlayAlpha *= 0.90;
      ctx.save();
      ctx.fillStyle = `rgba(255,255,255,${overlayAlpha*0.45})`;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    requestAnimationFrame(animate);
  }

  // Ponteiro (mantido para o coração)
  function setPointerFromEvent(ev){
    const rect = canvas.getBoundingClientClientRect ? canvas.getBoundingClientRect() : {left:0, top:0};
    pointer.x = (ev.clientX - rect.left) * DPR;
    pointer.y = (ev.clientY - rect.top) * DPR;
    pointer.active = true;
  }
  canvas.addEventListener('pointermove', e=>{ setPointerFromEvent(e); }, {passive:true});
  canvas.addEventListener('pointerdown', e=>{
    setPointerFromEvent(e);
    const now = performance.now();
    clickTimes.push(now);
    while(clickTimes.length && now - clickTimes[0] > params.strobeWindowMs) clickTimes.shift();
    const rate = clickTimes.length;
    const amp = Math.min(1, rate/6);
    const n = params.strobeBase + Math.floor(params.strobeFactor * amp);
    for(let k=0;k<n;k++){
      const ang = Math.random()*Math.PI*2;
      const jitter = (Math.random()*10 + 8) * DPR;
      const x = pointer.x + Math.cos(ang)*jitter;
      const y = pointer.y + Math.sin(ang)*jitter;
      strobes.push({ x, y, r: 6*DPR, vr: params.strobeVR*DPR*(0.7+Math.random()*0.6), a: 0.9 });
    }
    overlayAlpha = Math.min(1, overlayAlpha + params.strobeOverlayGain * amp);
  }, {passive:true});
  canvas.addEventListener('pointerup',   ()=>{ pointer.active = false; }, {passive:true});
  canvas.addEventListener('pointerleave',()=>{ pointer.active = false; }, {passive:true});
  window.addEventListener('keydown', e=>{ if(e.code === 'Space' || e.key === 'r' || e.key === 'R'){ regenerate(); }});
  window.addEventListener('resize', resize);

  // Init
  resize();
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>

